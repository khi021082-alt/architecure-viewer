<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê±´ì¶• ì›¹ ìŠ¤íŠœë””ì˜¤ Pro</title>
    <style>
        /* --- ê¸°ë³¸ UI ìŠ¤íƒ€ì¼ --- */
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #f0f2f5; }
        #canvas-container { width: 100vw; height: 100vh; display: block; outline: none; }

        /* íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë²„ë ˆì´ */
        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(5px);
            z-index: 20; transition: opacity 0.5s;
        }
        body.loaded #ui-overlay { pointer-events: none; opacity: 0; }
        .upload-box {
            border: 2px dashed #0078d4; padding: 40px; border-radius: 12px;
            text-align: center; background: white; box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .custom-file-upload {
            display: inline-block; padding: 12px 24px; cursor: pointer;
            background-color: #0078d4; color: white; border-radius: 6px; font-weight: bold; margin-top: 15px;
        }
        input[type="file"] { display: none; }

        /* --- ì™¼ìª½ íŒ¨ë„ (Navisworks ìŠ¤íƒ€ì¼) --- */
        #left-panel {
            position: absolute; top: 20px; left: 20px; width: 280px;
            background: rgba(30, 30, 30, 0.85); color: white;
            border-radius: 8px; padding: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px); display: none; z-index: 10;
        }
        body.loaded #left-panel { display: block; }
        
        .panel-section { margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 15px; }
        .panel-title { font-size: 16px; font-weight: bold; margin-bottom: 10px; color: #4cc9f0; display: flex; justify-content: space-between; align-items: center;}
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 14px; }
        
        /* í† ê¸€ ìŠ¤ìœ„ì¹˜ */
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #0078d4; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* ìŠ¬ë¼ì´ë”(Range) ìŠ¤íƒ€ì¼ */
        input[type=range] { width: 100%; margin: 5px 0; accent-color: #0078d4; }
        .range-label { display: flex; justify-content: space-between; font-size: 12px; color: #aaa; }

        /* --- ì˜¤ë¥¸ìª½ ìƒë‹¨ ë·°íë¸Œ --- */
        #viewcube-container {
            position: absolute; top: 20px; right: 20px; width: 100px; height: 100px;
            z-index: 10; pointer-events: none; /* íë¸ŒëŠ” ì‹œê°ìš© */
        }

        /* í•˜ë‹¨ ì •ë³´ë°” */
        #status-bar {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(0,0,0,0.8); color: #ccc; font-size: 12px;
            padding: 5px 20px; box-sizing: border-box; display: flex; justify-content: space-between;
            z-index: 10;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- ì—…ë¡œë“œ ì˜¤ë²„ë ˆì´ -->
    <div id="ui-overlay">
        <div class="upload-box">
            <h1 style="color:#0078d4; margin:0;">Architecture Studio</h1>
            <p>Revit GLB ë·°ì–´ & ë¶„ì„ ë„êµ¬</p>
            <label class="custom-file-upload">
                <input type="file" id="file-input" accept=".glb,.gltf">
                ëª¨ë¸ ì—´ê¸° (.glb)
            </label>
            <div id="loader" style="margin-top:15px; color:#666;"></div>
        </div>
    </div>

    <!-- ì™¼ìª½ íŒ¨ë„ -->
    <div id="left-panel">
        <!-- 1. ë³´í–‰ ëª¨ë“œ -->
        <div class="panel-section">
            <div class="panel-title">
                <span>ğŸƒ 3ì¸ì¹­ ë³´í–‰ ëª¨ë“œ</span>
                <label class="switch">
                    <input type="checkbox" id="toggle-walk">
                    <span class="slider"></span>
                </label>
            </div>
            <div style="font-size: 12px; color: #ccc; line-height: 1.4;">
                <span style="color:#ffcc00">WASD</span> ì´ë™ / <span style="color:#ffcc00">Space</span> ì í”„<br>
                <span style="color:#ffcc00">Shift</span> ë‹¬ë¦¬ê¸° / ë§ˆìš°ìŠ¤ë¡œ ë°©í–¥ ì „í™˜
            </div>
        </div>

        <!-- 2. ë‹¨ë©´ ë¶„ì„ -->
        <div class="panel-section">
            <div class="panel-title">
                <span>âœ‚ï¸ ë‹¨ë©´ ë¶„ì„ (Clipping)</span>
                <label class="switch">
                    <input type="checkbox" id="toggle-clip">
                    <span class="slider"></span>
                </label>
            </div>
            
            <div id="clip-controls" style="opacity: 0.5; pointer-events: none;">
                <div class="range-label"><span>Xì¶• ë‹¨ë©´</span></div>
                <input type="range" id="clip-x" min="-100" max="100" step="0.1">
                
                <div class="range-label"><span>Yì¶• ë‹¨ë©´ (ë†’ì´)</span></div>
                <input type="range" id="clip-y" min="-100" max="100" step="0.1">
                
                <div class="range-label"><span>Zì¶• ë‹¨ë©´</span></div>
                <input type="range" id="clip-z" min="-100" max="100" step="0.1">
                
                <div style="margin-top:10px;">
                    <label style="font-size:12px;"><input type="checkbox" id="clip-invert"> ë°©í–¥ ë°˜ì „ (Invert)</label>
                </div>
            </div>
        </div>

        <!-- 3. ë·°ì–´ ì„¤ì • -->
        <div class="panel-section" style="border:none;">
            <div class="panel-title">âš™ï¸ ì„¤ì •</div>
            <div class="control-row">
                <span>ê·¸ë¦¬ë“œ(ë°”ë‹¥) í‘œì‹œ</span>
                <input type="checkbox" id="toggle-grid" checked>
            </div>
        </div>
    </div>

    <!-- ì˜¤ë¥¸ìª½ ìƒë‹¨ ë·°íë¸Œ -->
    <div id="viewcube-container"></div>

    <!-- 3D ìº”ë²„ìŠ¤ -->
    <div id="canvas-container"></div>

    <!-- í•˜ë‹¨ ìƒíƒœë°” -->
    <div id="status-bar">
        <span>MODE: <span id="mode-text" style="color:#fff; font-weight:bold;">Orbit (Revit Style)</span></span>
        <span>ğŸ–±ï¸ Wheel: Zoom | Wheel Drag: Pan | Shift+Drag: Rotate</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // --- ì „ì—­ ë³€ìˆ˜ ---
        let scene, camera, renderer, controls;
        let modelContainer, gridHelper;
        let clippingPlanes = [];
        let modelBounds = { min: new THREE.Vector3(), max: new THREE.Vector3(), size: new THREE.Vector3() };

        // ë·°íë¸Œ ê´€ë ¨
        let cubeScene, cubeCamera, cubeRenderer, viewCubeMesh;

        // ë³´í–‰ ëª¨ë“œ ê´€ë ¨
        let isWalkMode = false;
        let player, playerVelocity = new THREE.Vector3(), playerDirection = new THREE.Vector3();
        let keyStates = {};
        let raycaster = new THREE.Raycaster(); // ë°”ë‹¥ ê°ì§€ìš©
        let playerOnFloor = false;

        // ì´ˆê¸°í™”
        init();
        initViewCube();
        animate();

        function init() {
            const container = document.getElementById('canvas-container');

            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000);
            camera.position.set(50, 50, 50);

            // 3. Renderer (Clipping í™œì„±í™” í•„ìˆ˜)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.localClippingEnabled = true; // ë‹¨ë©´ ë¶„ì„ì„ ìœ„í•´ í•„ìˆ˜
            container.appendChild(renderer.domElement);

            // 4. Environment
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            // 5. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 6. Controls (Revit ìŠ¤íƒ€ì¼ - Shift ë¬¸ì œ í•´ê²°)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            
            // ê¸°ë³¸ ë§¤í•‘: íœ (MIDDLE) = PAN (ì´ë™)
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE, // ì™¼ìª½ë„ íšŒì „ ê°€ëŠ¥í•˜ê²Œ (í¸ì˜ìƒ)
                MIDDLE: THREE.MOUSE.PAN,
                RIGHT: THREE.MOUSE.ROTATE
            };

            // Shift í‚¤ ë¦¬ìŠ¤ë„ˆ (OrbitControls ë‚´ë¶€ ë™ì‘ê³¼ ì¶©ëŒ ë°©ì§€)
            window.addEventListener('keydown', (e) => {
                keyStates[e.code] = true;
                if (e.key === 'Shift') {
                    controls.mouseButtons.MIDDLE = THREE.MOUSE.ROTATE;
                    // ì»¤ì„œ ë³€ê²½ìœ¼ë¡œ ì‹œê°ì  í”¼ë“œë°±
                    document.body.style.cursor = 'move';
                }
            });

            window.addEventListener('keyup', (e) => {
                keyStates[e.code] = false;
                if (e.key === 'Shift') {
                    controls.mouseButtons.MIDDLE = THREE.MOUSE.PAN;
                    document.body.style.cursor = 'default';
                }
            });

            // 7. Clipping Planes (ë‹¨ë©´ ë¶„ì„ìš©) - ì´ˆê¸°ì—” ë¹„í™œì„±
            // X, Y, Z í‰ë©´ ìƒì„±
            clippingPlanes = [
                new THREE.Plane(new THREE.Vector3(1, 0, 0), 0), // X
                new THREE.Plane(new THREE.Vector3(0, -1, 0), 0), // Y (Top-down)
                new THREE.Plane(new THREE.Vector3(0, 0, 1), 0)  // Z
            ];

            // 8. Player (Avatar) Setup
            const geometry = new THREE.CapsuleGeometry(1, 4, 4, 8); // ì‚¬ëŒ í¬ê¸°
            const material = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            player = new THREE.Mesh(geometry, material);
            player.visible = false; // ì²˜ìŒì—” ìˆ¨ê¹€
            player.castShadow = true;
            scene.add(player);

            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
            window.addEventListener('resize', onWindowResize);
            setupUIEvents();
        }

        // --- ë·°íë¸Œ(ViewCube) ìƒì„± ---
        function initViewCube() {
            const container = document.getElementById('viewcube-container');
            
            cubeScene = new THREE.Scene();
            cubeCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            cubeCamera.position.z = 5;

            cubeRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            cubeRenderer.setSize(100, 100);
            cubeRenderer.setClearColor(0x000000, 0);
            container.appendChild(cubeRenderer.domElement);

            // íë¸Œ í…ìŠ¤ì²˜ ìƒì„± í•¨ìˆ˜
            function createLabelTexture(text) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ddd'; // ë°°ê²½
                ctx.fillRect(0, 0, 128, 128);
                ctx.lineWidth = 10;
                ctx.strokeStyle = '#0078d4'; // í…Œë‘ë¦¬
                ctx.strokeRect(0,0,128,128);
                ctx.fillStyle = '#333';
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 64, 64);
                return new THREE.CanvasTexture(canvas);
            }

            const materials = [
                new THREE.MeshBasicMaterial({ map: createLabelTexture('RIGHT') }), // +x
                new THREE.MeshBasicMaterial({ map: createLabelTexture('LEFT') }),  // -x
                new THREE.MeshBasicMaterial({ map: createLabelTexture('TOP') }),   // +y
                new THREE.MeshBasicMaterial({ map: createLabelTexture('BOTTOM') }),// -y
                new THREE.MeshBasicMaterial({ map: createLabelTexture('FRONT') }), // +z
                new THREE.MeshBasicMaterial({ map: createLabelTexture('BACK') })   // -z
            ];

            viewCubeMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), materials);
            cubeScene.add(viewCubeMesh);
        }

        // --- íŒŒì¼ ë¡œë“œ ë¡œì§ ---
        const loader = new GLTFLoader();
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadGLB(URL.createObjectURL(file));
        });

        function loadGLB(url) {
            document.getElementById('loader').innerText = "ë¡œë”© ë° ìµœì í™” ì¤‘...";
            
            loader.load(url, (gltf) => {
                if (modelContainer) scene.remove(modelContainer);
                modelContainer = gltf.scene;

                // ëª¨ë¸ ë¶„ì„
                const box = new THREE.Box3().setFromObject(modelContainer);
                box.getSize(modelBounds.size);
                box.getCenter(modelBounds.min); // ì¤‘ì‹¬ì  ì„ì‹œ ì €ì¥

                const maxDim = Math.max(modelBounds.size.x, modelBounds.size.y, modelBounds.size.z);
                
                // ìœ„ì¹˜ ë³´ì •
                modelContainer.position.x -= modelBounds.min.x;
                modelContainer.position.z -= modelBounds.min.z;
                modelContainer.position.y -= box.min.y; // ë°”ë‹¥ì„ 0ì— ë§ì¶¤

                // ì¬ì§ˆ ì„¤ì • (ê·¸ë¦¼ì ë° í´ë¦¬í•‘)
                modelContainer.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // ë‹¨ë©´ ë¶„ì„ì„ ìœ„í•´ í´ë¦¬í•‘ í‰ë©´ ì—°ê²° (í™œì„±í™”ëŠ” ë Œë”ëŸ¬ì—ì„œ ì œì–´í•˜ì§€ë§Œ ì¬ì§ˆì— í• ë‹¹ í•„ìš”)
                        child.material.clippingPlanes = clippingPlanes;
                        child.material.clipShadows = true;
                        // ì–‘ë©´ ë Œë”ë§ (ì˜ë ¸ì„ ë•Œ êµ¬ë© ì•ˆ ë³´ì´ê²Œ)
                        child.material.side = THREE.DoubleSide; 
                    }
                });

                scene.add(modelContainer);

                // ì¹´ë©”ë¼ ë° ì»¨íŠ¸ë¡¤ ì¬ì„¤ì •
                camera.position.set(maxDim, maxDim, maxDim);
                camera.far = maxDim * 50;
                camera.updateProjectionMatrix();
                
                controls.target.set(0, modelBounds.size.y / 2, 0);
                controls.maxDistance = maxDim * 5;
                controls.update();

                // í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜ ì„¤ì • (ëª¨ë¸ ì•½ê°„ ìœ„)
                player.position.set(0, maxDim * 0.5, maxDim);

                // ê·¸ë¦¬ë“œ ì—…ë°ì´íŠ¸
                if (gridHelper) scene.remove(gridHelper);
                gridHelper = new THREE.GridHelper(maxDim * 5, 50, 0x888888, 0xcccccc);
                scene.add(gridHelper);

                // UI ì—…ë°ì´íŠ¸
                updateClipSliders(maxDim);
                document.body.classList.add('loaded');

            }, undefined, (err) => {
                console.error(err);
                alert("íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨");
            });
        }

        // --- UI ì´ë²¤íŠ¸ ì„¤ì • ---
        function setupUIEvents() {
            // 1. ë³´í–‰ ëª¨ë“œ í† ê¸€
            document.getElementById('toggle-walk').addEventListener('change', (e) => {
                isWalkMode = e.target.checked;
                player.visible = isWalkMode;
                document.getElementById('mode-text').innerText = isWalkMode ? "Walk (3rd Person)" : "Orbit (Revit Style)";
                
                if (isWalkMode) {
                    controls.enabled = false; // ì˜¤ë¹— ì»¨íŠ¸ë¡¤ ë„ê¸°
                    // ì¹´ë©”ë¼ë¥¼ í”Œë ˆì´ì–´ ë’¤ë¡œ ì´ë™
                    const offset = modelBounds.size.y > 0 ? modelBounds.size.y * 0.2 : 10;
                    player.position.y = offset; // ê³µì¤‘ì—ì„œ ì‹œì‘
                    playerVelocity.set(0,0,0);
                } else {
                    controls.enabled = true; // ì˜¤ë¹— ì»¨íŠ¸ë¡¤ ì¼œê¸°
                    controls.target.copy(player.position); // í˜„ì¬ ìœ„ì¹˜ë¥¼ íƒ€ê²Ÿìœ¼ë¡œ
                }
            });

            // 2. ë‹¨ë©´ ë¶„ì„ í† ê¸€ ë° ìŠ¬ë¼ì´ë”
            const clipControlDiv = document.getElementById('clip-controls');
            document.getElementById('toggle-clip').addEventListener('change', (e) => {
                const enabled = e.target.checked;
                renderer.localClippingEnabled = enabled;
                clipControlDiv.style.opacity = enabled ? "1" : "0.5";
                clipControlDiv.style.pointerEvents = enabled ? "auto" : "none";
            });

            ['x', 'y', 'z'].forEach((axis, index) => {
                document.getElementById(`clip-${axis}`).addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    const invert = document.getElementById('clip-invert').checked ? -1 : 1;
                    // í‰ë©´ ìƒìˆ˜ ì—…ë°ì´íŠ¸
                    clippingPlanes[index].constant = val * invert;
                });
            });

            document.getElementById('clip-invert').addEventListener('change', (e) => {
                const invert = e.target.checked;
                // í‰ë©´ ë²•ì„  ë²¡í„° ë°˜ì „
                clippingPlanes[0].normal.set(invert ? -1 : 1, 0, 0);
                clippingPlanes[1].normal.set(0, invert ? 1 : -1, 0); // YëŠ” ê¸°ë³¸ì´ -1 (ìœ„ì—ì„œ ì•„ë˜ë¡œ)
                clippingPlanes[2].normal.set(0, 0, invert ? -1 : 1);
            });

            // 3. ê·¸ë¦¬ë“œ í† ê¸€
            document.getElementById('toggle-grid').addEventListener('change', (e) => {
                if (gridHelper) gridHelper.visible = e.target.checked;
            });
        }

        function updateClipSliders(size) {
            ['x', 'y', 'z'].forEach(axis => {
                const slider = document.getElementById(`clip-${axis}`);
                slider.min = -size;
                slider.max = size;
                slider.value = axis === 'y' ? size : 0; // YëŠ” ì²œì¥ë¶€í„° ì‹œì‘
            });
            // ì´ˆê¸°ê°’ ì ìš©
            clippingPlanes[1].constant = size; 
        }

        // --- ë©”ì¸ ë£¨í”„ ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = 0.016; // ëŒ€ëµ 60fps

            if (isWalkMode) {
                updatePlayer(delta);
            } else {
                controls.update();
            }

            // ë·°íë¸Œ ë™ê¸°í™” (ë©”ì¸ ì¹´ë©”ë¼ íšŒì „ ë”°ë¼ê°€ê¸°)
            cubeCamera.rotation.copy(camera.rotation);
            cubeRenderer.render(cubeScene, cubeCamera);

            renderer.render(scene, camera);
        }

        // --- í”Œë ˆì´ì–´ ë¬¼ë¦¬/ì´ë™ ë¡œì§ ---
        function updatePlayer(delta) {
            // 1. WASD ì…ë ¥ ì²˜ë¦¬
            const speed = keyStates['ShiftLeft'] || keyStates['ShiftRight'] ? 200 : 80; // ìŠ¤í”¼ë“œ
            const actualSpeed = speed * delta;
            
            // ì¹´ë©”ë¼ê°€ ë³´ëŠ” ë°©í–¥ ê¸°ì¤€ ê³„ì‚°
            // ì¹´ë©”ë¼ì˜ ì• ë°©í–¥ ë²¡í„° (Yì¶• ì œì™¸)
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            // ì´ë™ ë°©í–¥ í•©ì‚°
            playerDirection.set(0, 0, 0);
            if (keyStates['KeyW']) playerDirection.add(forward);
            if (keyStates['KeyS']) playerDirection.sub(forward);
            if (keyStates['KeyA']) playerDirection.sub(right);
            if (keyStates['KeyD']) playerDirection.add(right);

            if (playerDirection.length() > 0) {
                playerDirection.normalize();
                player.position.addScaledVector(playerDirection, actualSpeed);
            }

            // 2. ì í”„ ë° ì¤‘ë ¥
            if (keyStates['Space'] && playerOnFloor) {
                playerVelocity.y = 60; // ì í”„ í˜
                playerOnFloor = false;
            }

            playerVelocity.y -= 150 * delta; // ì¤‘ë ¥
            player.position.y += playerVelocity.y * delta;

            // 3. ë°”ë‹¥ ì¶©ëŒ ê°ì§€ (Raycasting)
            // í”Œë ˆì´ì–´ ìœ„ì¹˜ì—ì„œ ì•„ë˜ë¡œ ë¹”ì„ ì¨
            raycaster.set(player.position, new THREE.Vector3(0, -1, 0));
            // ëª¨ë¸ê³¼ ì¶©ëŒ ê²€ì‚¬
            const intersects = modelContainer ? raycaster.intersectObject(modelContainer, true) : [];
            
            // í”Œë ˆì´ì–´ í‚¤/2 (ìº¡ìŠ ì¤‘ì‹¬ì—ì„œ ë°”ë‹¥ê¹Œì§€)
            const playerHeight = 2; 

            if (intersects.length > 0) {
                const dist = intersects[0].distance;
                if (dist < playerHeight && playerVelocity.y <= 0) {
                    // ë•…ì— ë‹¿ìŒ
                    player.position.y = intersects[0].point.y + playerHeight;
                    playerVelocity.y = 0;
                    playerOnFloor = true;
                } else {
                    playerOnFloor = false;
                }
            } else if (player.position.y < playerHeight) {
                // ëª¨ë¸ì´ ì—†ì–´ë„ ë°”ë‹¥(y=0) ì•„ë˜ë¡œ ì•ˆ ë–¨ì–´ì§€ê²Œ
                player.position.y = playerHeight;
                playerVelocity.y = 0;
                playerOnFloor = true;
            }

            // 4. ì¹´ë©”ë¼ê°€ í”Œë ˆì´ì–´ë¥¼ ë”°ë¼ë‹¤ë‹ˆê²Œ ì„¤ì • (TPS View)
            const camDist = 20;
            const camHeight = 15;
            
            // ëª©í‘œ ì¹´ë©”ë¼ ìœ„ì¹˜ (í”Œë ˆì´ì–´ ë’¤ìª½ ìœ„)
            // í˜„ì¬ ì¹´ë©”ë¼ ê°ë„ ìœ ì§€í•˜ë©´ì„œ ìœ„ì¹˜ë§Œ ì´ë™
            // ê°„ë‹¨í•˜ê²Œ: í˜„ì¬ ì˜¤ë¹— ì»¨íŠ¸ë¡¤ ê°ë„ë¥¼ ìœ ì§€í•˜ë©° íƒ€ê²Ÿë§Œ í”Œë ˆì´ì–´ë¡œ ë³€ê²½
            
            // ì¹´ë©”ë¼ ë¶€ë“œëŸ¬ìš´ ì¶”ì 
            const relativeCameraOffset = new THREE.Vector3(0, camHeight, -camDist);
            // í”Œë ˆì´ì–´ íšŒì „ì´ ì—†ìœ¼ë¯€ë¡œ ë‹¨ìˆœ ìœ„ì¹˜ ì˜¤í”„ì…‹ì€ ì–´ìƒ‰í•  ìˆ˜ ìˆìŒ.
            // ëŒ€ì‹ , ì´ì „ ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ë²¡í„°ë¥¼ ìœ ì§€í•˜ë©° í”Œë ˆì´ì–´ ìœ„ì¹˜ë¡œ ì´ë™
            
            // ê°€ì¥ ì‰¬ìš´ TPS: í”Œë ˆì´ì–´ ìœ„ì¹˜ + í˜„ì¬ ì¹´ë©”ë¼ ë°©í–¥ ë°˜ëŒ€
            const currentDir = new THREE.Vector3();
            camera.getWorldDirection(currentDir);
            
            const targetPos = player.position.clone().sub(currentDir.multiplyScalar(camDist));
            targetPos.y += camHeight; // ì•½ê°„ ìœ„ì—ì„œ
            
            // ë¶€ë“œëŸ½ê²Œ ì´ë™ (Lerp)
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
